# ■ 「UE4におけるレベル制作事例」の要約

# ■ スライドへのリンク
* [{SlideShare} UE4におけるレベル制作事例](https://www.slideshare.net/EpicGamesJapan/ue4-137253034)

# ■ 要約
* 概要
	* UE4 の特徴である BP/Level/LevelStreaming を使っての開発にあたり、  
	  具体的なサブレベルの分け方や機能拡張、デバッグ方法等を事例を交えてまとめられています。
	* 特にボリュームが多い項目は以下の通りです。
		* BP ならではの進め方と問題と対処方法
		* サブレベルの分け方
		* レベルストリーミングに関する情報
		* レベルの最適化の手法やそれにあたっての有用だった拡張内容
* 読むべき人
	* プログラマー（リード、担当箇所が BP 寄りのエンジニア、自動化・ビルド担当）
	* プランナー（レベルデザイナー）
	* デザイナー（BP 寄りの担当者）

# ■ スライドの内容
* プログラマーの吉田武史氏の講演
	* BP サポート担当から始まり、最終的にレベルプログラム担当

# ■ スライド内容のメモ
* ※ここから先はほぼスライドの内容全部を書き写しただけのスライド全体の俯瞰用のテキスト
* ブループリント
	* 使用頻度は職種に依らず高い頻度で利用していた
		* プランナー
			* 仕掛け、ゲーム性検証、ミニゲーム、カメラ挙動
		* プログラマー
			* 仕掛け、ミニゲーム
		* デザイナー
			* 見た目の調整、演出強化
	* ルール
		* Tick
			* なるべく使わない（処理負荷とグラフの複雑化回避のため）
			* 使う時だけ ON にして終わったら OFF という使い方
			* プログラマが定期的に使用状況を調査し、使用していた場合は担当者とすり合わせ
				* これを行うことで、なるべく使わないという意識が浸透した
		* 親クラス
			* なるべく C++ にした
			* **RazorCPU などのプロファイラとの相性がよくなる**
			* BP クラスロード時に親 BP が持つアセットをロードしてしまう問題がある
				* C++ でも同様にできるが、コーディングルールとして禁止した
		* インプットイベント
			* レベル上で設定できるインプットイベントはエディタのみに限定した（製品に残らないように）
		* BP マクロ
			* 積極的に利用している
				* 担当者ごとの設計が独立しないように
				* 利用頻度の高いノードもラッピングしたものをつかうように
			* エンジニアが定期的に内容の確認、整理できる部分は担当者と相談
				* 未使用変数、 Transient フラグをつけたものがいいものなど
				* BP クラスへのキャストも注意が必要
					* メモリに乗っていないクラスの場合ロードが発生
					* 適切なクラスにキャストしているか
	* 使用して困った事
		* 何でも出来る
			* 力づくの実装で拡張が難しくなってしまったもの
				* プログラマーの対応が容易なものが多かった
		* パフォーマンスで問題が多数
			* ノード、コンポーネントの想定外の使われ方
				* 大量のコンポーネントが付けられているケース
				* ChildActorComponent が起因の不具合
				* 根深い場合はポログラマー側で作り直しもした
			* 知見がたまれば回避できる
		* 可読性の低いものが多く、作りに性格が出る
		* バグが非常に多かった
			* 非エンジニアも使っていた、習熟度の差もあった為、バリエーション豊かなバグが発生
			* 人為的ミスが主だった
			* すべてのカスタムイベントや特定のアクターの配置情報をテキストで書き出すコマンドレットを作成
			* それを参考に各セクション担当者が対応
			* 設計ミスのものはエンジニアが巻き取り
			* 失敗の経験が活き、プロジェクトの後半では各セクションで対応できる項目が増えた
	* 作成して有用だった機能
		* Bool から Bit への機能修正
			* bool をある程度まとめた bit というフラグをひとまとめにしたセットを作り、すべて立っていないと偽として扱う仕組み
			* **詳細はスライド参照**
* レベルの構成
	* １パーシスタントレベルのサブレベル数
		* 30 ～ 200
		* サブレベルが多いと管理、レベルストリーミングが難航
	* １パーシスタントレベルのアクター数
		* 8000 ～ 16000 (エディタ上の数字)
		* インゲーム中はレベルストリーミングの関係で大部分のアクターが削られる為もっと少ない数で動いている
	* サブレベルのカテゴリ分け
		* ゲームフロー
			* パーシスタントレベルの BeginPlay からゲームが始まるまでの流れ
			* 各サブレベルと RemoteEvent を使ってのやり取り
			* ボリュームとオーバーラップした際の処理
			* ミニゲーム、カットシーン等のフロー
			* レベル表示周り処理（レベルストリーミング含む）
		* エネミー
		* 拝啓
		* エフェクト
		* サウンド
		* 仕掛け
		* リアルタイム演出
		* カットシーンボイス
		* NPC
		* 宝箱
		* ミニゲーム
		* 専用ミッション
		* 風
	* サブレベルの切り分け
		* プレイヤーの位置によるレベルの分割
		* 分割は各セクションで行っていた
		* 表示制御はプランナーが担当
		* 処理負荷などの状況で、レベルストリーミングが間に合わない問題がよく起きた
* レベルストリーミング
	* 当初はゲームデザイン的な問題やスパイクが高く対応を見送りたかった
	* メモリが枯渇したため、対応せざるを得なくなった
	* スパイク
		* 原因の大半はガベージコレクト関係
			* エンジン改造＋データ調整で対応
			* [UE4 における Loading と GC の Profiling と最適化手法](https://www.slideshare.net/EpicGamesJapan/420-ue4loadinggcprofiling-108367408)
			* UObject の削減
			* 不要なコンポーネントの削減
		* レベルストリーミングに関する UE4 側の変数の値調整
			* **詳細はスライド参照**
		* ULevel::RouteActorInitialize
			* ロード時のアクター初期化処理
				* 一定の負荷を超えた場合ログ表示するようにした
				* 中身の処理が不要なケースもあったため、フラグを追加しアクターごとに指定できるように拡張した
		* UNavigationSystem::Tick
			* NavLinkProxy/NavModifierVolume/NavModifierComponent が付いている Actor のスポーン時
			* ナビゲーションメッシュの更新が発生
			* NavData->TickAsyncBuild(deltaSeconds) の呼び出しが原因になっていた
				* 一定の負荷を超えた場合ログ表示するようにした
		* アクターの配置位置などのレベルの調整によって結果が変わるため、監視が必要だった
	* パッケージを使用してのチェック
		* 製品と同等のアセット構成やプログラムが必要になるため、毎日チェック下がビルドに時間がかかるのがネックだった
		* ロードが間に合わないことによる調整は理論的なものではなく感覚で設定していたためトライアンドエラーが多かった
		* 実機確認の際、パッケージデータはそのままでプログラムだけ差し替えることはできたので、プログラムの問題の対応はしやすかった
	* 他の AsysncLoad との競合
		* AsysncLoad 発生中はレベルストリーミングはサスペンドされる
		* 単にロードが長いだけなのか分かりづらく、発見しずらかった
		* サブレベル変更時に画面上に表示するようにしたことで気づいた
			* 一部の場所で動的にデータをロードしていたため発生していた
			* その場所だけ該当データを常駐することで対処した
	* 作って便利だった機能
		* サブレベルの状態を画面上に表示するデバッグ機能
			* 用途：ストリーミングの発行タイミング、ロードから表示までの時間計測などの確認に有用だった
* レベルの最適化
	* 調査のための仕組み
		* サブレベルデバッグ UMG を作成した
			* 用途：サブレベルごとのロード、アンロードを行えるように、負荷が高いレベルの特定が容易になるように
			* 手軽に作れる上に各セクションでの利用が容易なため有用だった
		* 負荷が高いアクターを名前等とともに画面に表示するように
			* FAutoConsoleVariableRef が有用だった
			* FAutoConsoleCommand も有用
		* 専用内製 CPU プロファイラ
			* スレッドの使用状況、 TickGroup の Tick 数、事前登録した関数を負荷が高い順で表示する機能、タイムライン、ポーズ巻き戻し
	* 最適化施策
		* 並列 Tick システムの作成
			* 「ゲームスレッド専用処理」「どのスレッドでも実行可能処理」のいずれかを選べるように
			* プライオリティの設定
			* 処理の分散実行機能
			* **詳細はスライド参照**
	* 距離による表示制御
		* 遠い時に OFF にする機能、オプションで Tick も OFF にする機能
	* 移動オブジェクトのコリジョン制御
		* 遠い時に OFF にする機能
	* 厳密な Tick 制御
		* その時使用していないものは徹底的に OFF に
			* 宝箱はアニメーション中だけ SkeltalMeshComponent の Tick を ON にする、など
		* Actor に Tick を持たせず、複数のアクターの更新管理を行うマネージャクラスを用意しその Tick から Actor の更新処理を呼び出す、など


----
以上。
